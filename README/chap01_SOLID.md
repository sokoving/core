# 1강 스프링 핵심 원리

# 라이브러리와 프레임워크
1. 라이브러리
- 클래스, 인터페이스, 메서드를 제공만 하는 것

2. 프레임워크
- 객체 생성, 제어, 실행권까지 가지고 있다
- 개발, 실행의 제어권을 일정 부분 가져간다
- 자동화

3. 스프링 프레임워크
- 자바 언어 기반의 프레임워크
 + 단순히 웹 애플리케이션 개발에 국한되지 않는다
- 스프링을 사용하면 강력한 *객체 지향 애플리케이션*을 만들 수 있다.


# OOP
- 프로그램을 객체의 모임으로 규정
 + 각각의 객체는 메세지를 주고받고 데이터를 처리할 수 있다
 + 객체는 역할과 구현체로 구분한다
- OOP 프로그램은 유연하고 변경이 쉽다 (다형성)
 + 대규모 소프트웨어 개발에 적합

# 역할과 구현체
- 역할 : 인터페이스, 추상클래스 (기본틀)
- 구현체 : 클래스 (공유하는 공통사항은 있지만 각기 다른 객체이며 특성이 다르다)

- 컴포넌트들을 역할과 구현으로 구분 짓고
 + 구현보다는 역할에 의지해야
 + 강력하고 유연한 객체지향 프로그래밍이 가능하다

- chap01_1은 다형성은 지켰지만 역할과 구현이 동시에 되어 있기 때문에
 + SOLD 원칙에 위배된다
- chap01_2는 구현(객체 생성)을 HotelManager에 위임해 역할과 구현을 구분했다


# SOLID 원칙 (좋은 객체지향 설계의 5가지 원칙)
• SRP: 단일 책임 원칙
• OCP: 개방-폐쇄 원칙
• LSP: 리스코프 치환 원칙
• ISP: 인터페이스 분리 원칙
• DIP: 의존관계 역전 원칙

## 1. SRP(Single Responsibility Principle)
- [단일 책임 원칙]
- 하나의 클래스는 하나의 책임만 가져야 한다.
  ex) view 클래스는 화면 출력만을 담당한다.
  repository 클래스는 디비 연결만을 담당한다
- SRP를 적용하면 책임 영역이 확실해지기 때문에 변경의 연쇄작용에서
  자유로워질 수 있습니다.
- 또한 코드의 가독성 향상, 유지보수 용이라는 이점도 누릴 수 있습니다.

## 2. OCP(Open Closed Principle)
- [개방 폐쇄 원칙]
- 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 요구사항의 변경이나 추가사항이 발생했을 때 기존 구성요소에는
  수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장하여
  재사용할 수 있어야 한다는 것입니다.
- 이를 가능케 하는 중요 메커니즘은 *다형성*과 *추상화*입니다.

## 3. LSP(Liskov Subtitution Principle)
- [리스코프 치환 원칙]
+ 인터페이스 규약을 지켜서 오버라이딩을 하자.
- 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입 인스턴스로
  변경할 수 있어야 한다.
- 하위 타입 인스턴스는 다른 인스턴스로 교체될 때 상위 타입의 규약을
  지켜야 한다는 뜻입니다.
- 예를 들면 자동차(하위타입 인스턴스)를 바꿀 때 아반떼가 소나타로
  바뀌어도 반드시 accelarator의 규약은 속도가 증가해야 한다는
  인터페이스의 규약을 지켜야 한다는 것입니다


## 4. ISP(Interface Segregation Principle)
- [인터페이스 분리 원칙]
+ 인터페이스에도 SRP 원칙을 적용해야 한다
- 특정 클라이언트를 위한 여러 개의 인터페이스가 하나의 범용 인터페이스보다 낫다.
- SRP가 클래스의 단일 책임을 의미한다면, ISP는 인터페이스의 단일 책임을 의미합니다.
- 예를 들면 자동차 인터페이스에는 운전에 관한 기능들과 정비에 관한 기능들이
  모두 명세 되어 있는 것 보다는 모든 운전자가 모두 자가정비를 하는 것이 아니기
  때문에 운전 인터페이스와 정비 인터페이스로 따로 분리하는 것이 좋습니다

## 5. DIP(Dependency Inversion Principle)
- [의존관계 역전 원칙]
- 구현 클래스에 의존하지 말고 인터페이스에 의존하라.
- 객체 지향 설계에서는 반드시 클라이언트는 역할에 의존하지 않고
  구현체에 의존하는 순간 변경이 아주 어려워집니다.


