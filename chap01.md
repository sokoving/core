# 라이브러리와 프레임워크
1. 라이브러리
- 클래스, 인터페이스, 메서드를 제공하는 것

2. 프레임워크
- 객체 생성, 제어, 실행권까지 가지고 있다
- 개발, 실행의 제어권을 일정 부분 가져간다
- 자동화

3. 스프링 프레임워크
- 모듈의 집합체


# OOP
- 프로그램을 객체의 모임으로 규정
 + 각각의 객체는 메세지를 주고받고 데이터를 처리할 수 있다
 + 객체는 역할과 구현체로 구분한다
- OOP 프로그램은 유연하고 변경이 쉽다 (다형성)
 + 대규모 소프트웨어 개발에 적합

# 역할과 구현체
역할 : 인터페이스, 추상클래스 (기본틀)
구현체 : 클래스 (공유하는 공통사항은 있지만 각기 다른 객체이며 특성이 다르다)
+ 컴포넌트들을 역할과 구현으로 구분 지으면
+ 유연하며 변경이 쉬운 프로그램이 만들어진다


# SOLD 원칙 (좋은 객체지향 설계의 5가지 원칙)
• SRP: 단일 책임 원칙
• OCP: 개방-폐쇄 원칙
• LSP: 리스코프 치환 원칙
• ISP: 인터페이스 분리 원칙
• DIP: 의존관계 역전 원칙

## 1. SRP(Single Responsibility Principle)
- [단일 책임 원칙]
- 하나의 클래스는 하나의 책임만 가져야 한다.
  ex) view 클래스는 화면 출력만을 담당한다.
  repository 클래스는 디비 연결만을 담당한다
- SRP를 적용하면 책임 영역이 확실해지기 때문에 변경의 연쇄작용에서
  자유로워질 수 있습니다.
- 또한 코드의 가독성 향상, 유지보수 용이라는 이점도 누릴 수 있습니다.

## 2. OCP(Open Closed Principle)
- [개방 폐쇄 원칙]
- 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 요구사항의 변경이나 추가사항이 발생했을 때 기존 구성요소에는
  수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장하여
  재사용할 수 있어야 한다는 것입니다.
- 이를 가능케 하는 중요 메커니즘은 *다형성*과 *추상화*입니다.

## 3. LSP(Liskov Subtitution Principle)
- [리스코프 치환 원칙]
+ 인터페이스 규약을 지켜서 오버라이딩을 하자.
- 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입 인스턴스로
  변경할 수 있어야 한다.
- 하위 타입 인스턴스는 다른 인스턴스로 교체될 때 상위 타입의 규약을
  지켜야 한다는 뜻입니다.
- 예를 들면 자동차(하위타입 인스턴스)를 바꿀 때 아반떼가 소나타로
  바뀌어도 반드시 accelarator의 규약은 속도가 증가해야 한다는
  인터페이스의 규약을 지켜야 한다는 것입니다


## 4. ISP(Interface Segregation Principle)
- [인터페이스 분리 원칙]
+ 인터페이스에도 SRP 원칙을 적용해야 한다
- 특정 클라이언트를 위한 여러 개의 인터페이스가 하나의 범용 인터페이스보다 낫다.
- SRP가 클래스의 단일 책임을 의미한다면, ISP는 인터페이스의 단일 책임을 의미합니다.
- 예를 들면 자동차 인터페이스에는 운전에 관한 기능들과 정비에 관한 기능들이
  모두 명세 되어 있는 것 보다는 모든 운전자가 모두 자가정비를 하는 것이 아니기
  때문에 운전 인터페이스와 정비 인터페이스로 따로 분리하는 것이 좋습니다

## 5. DIP(Dependency Inversion Principle)
- [의존관계 역전 원칙]
- 구현 클래스에 의존하지 말고 인터페이스에 의존하라.
- 객체 지향 설계에서는 반드시 클라이언트는 역할에 의존하지 않고
  구현체에 의존하는 순간 변경이 아주 어려워집니다.


